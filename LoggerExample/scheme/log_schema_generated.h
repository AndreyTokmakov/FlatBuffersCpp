// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGSCHEMA_LOGGINGSYSTEM_H_
#define FLATBUFFERS_GENERATED_LOGSCHEMA_LOGGINGSYSTEM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace LoggingSystem {

struct LogControlRequest;
struct LogControlRequestBuilder;

struct LogControlResponse;
struct LogControlResponseBuilder;

struct LogMessageHolder;
struct LogMessageHolderBuilder;

enum LogCommand : int8_t {
  LogCommand_Start = 0,
  LogCommand_Stop = 1,
  LogCommand_Pause = 2,
  LogCommand_MIN = LogCommand_Start,
  LogCommand_MAX = LogCommand_Pause
};

inline const LogCommand (&EnumValuesLogCommand())[3] {
  static const LogCommand values[] = {
    LogCommand_Start,
    LogCommand_Stop,
    LogCommand_Pause
  };
  return values;
}

inline const char * const *EnumNamesLogCommand() {
  static const char * const names[4] = {
    "Start",
    "Stop",
    "Pause",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogCommand(LogCommand e) {
  if (::flatbuffers::IsOutRange(e, LogCommand_Start, LogCommand_Pause)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogCommand()[index];
}

enum LogStatus : int8_t {
  LogStatus_Running = 0,
  LogStatus_Stopped = 1,
  LogStatus_Paused = 2,
  LogStatus_Error = 3,
  LogStatus_MIN = LogStatus_Running,
  LogStatus_MAX = LogStatus_Error
};

inline const LogStatus (&EnumValuesLogStatus())[4] {
  static const LogStatus values[] = {
    LogStatus_Running,
    LogStatus_Stopped,
    LogStatus_Paused,
    LogStatus_Error
  };
  return values;
}

inline const char * const *EnumNamesLogStatus() {
  static const char * const names[5] = {
    "Running",
    "Stopped",
    "Paused",
    "Error",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogStatus(LogStatus e) {
  if (::flatbuffers::IsOutRange(e, LogStatus_Running, LogStatus_Error)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogStatus()[index];
}

enum LogMessage : uint8_t {
  LogMessage_NONE = 0,
  LogMessage_LogControlRequest = 1,
  LogMessage_LogControlResponse = 2,
  LogMessage_MIN = LogMessage_NONE,
  LogMessage_MAX = LogMessage_LogControlResponse
};

inline const LogMessage (&EnumValuesLogMessage())[3] {
  static const LogMessage values[] = {
    LogMessage_NONE,
    LogMessage_LogControlRequest,
    LogMessage_LogControlResponse
  };
  return values;
}

inline const char * const *EnumNamesLogMessage() {
  static const char * const names[4] = {
    "NONE",
    "LogControlRequest",
    "LogControlResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogMessage(LogMessage e) {
  if (::flatbuffers::IsOutRange(e, LogMessage_NONE, LogMessage_LogControlResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogMessage()[index];
}

template<typename T> struct LogMessageTraits {
  static const LogMessage enum_value = LogMessage_NONE;
};

template<> struct LogMessageTraits<LoggingSystem::LogControlRequest> {
  static const LogMessage enum_value = LogMessage_LogControlRequest;
};

template<> struct LogMessageTraits<LoggingSystem::LogControlResponse> {
  static const LogMessage enum_value = LogMessage_LogControlResponse;
};

bool VerifyLogMessage(::flatbuffers::Verifier &verifier, const void *obj, LogMessage type);
bool VerifyLogMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct LogControlRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogControlRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4
  };
  LoggingSystem::LogCommand command() const {
    return static_cast<LoggingSystem::LogCommand>(GetField<int8_t>(VT_COMMAND, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMMAND, 1) &&
           verifier.EndTable();
  }
};

struct LogControlRequestBuilder {
  typedef LogControlRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(LoggingSystem::LogCommand command) {
    fbb_.AddElement<int8_t>(LogControlRequest::VT_COMMAND, static_cast<int8_t>(command), 0);
  }
  explicit LogControlRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogControlRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogControlRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogControlRequest> CreateLogControlRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoggingSystem::LogCommand command = LoggingSystem::LogCommand_Start) {
  LogControlRequestBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

struct LogControlResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogControlResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_MESSAGE = 6
  };
  LoggingSystem::LogStatus status() const {
    return static_cast<LoggingSystem::LogStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct LogControlResponseBuilder {
  typedef LogControlResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(LoggingSystem::LogStatus status) {
    fbb_.AddElement<int8_t>(LogControlResponse::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(LogControlResponse::VT_MESSAGE, message);
  }
  explicit LogControlResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogControlResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogControlResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogControlResponse> CreateLogControlResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoggingSystem::LogStatus status = LoggingSystem::LogStatus_Running,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  LogControlResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogControlResponse> CreateLogControlResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoggingSystem::LogStatus status = LoggingSystem::LogStatus_Running,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return LoggingSystem::CreateLogControlResponse(
      _fbb,
      status,
      message__);
}

struct LogMessageHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogMessageHolderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THE_MESSAGE_TYPE = 4,
    VT_THE_MESSAGE = 6
  };
  LoggingSystem::LogMessage the_message_type() const {
    return static_cast<LoggingSystem::LogMessage>(GetField<uint8_t>(VT_THE_MESSAGE_TYPE, 0));
  }
  const void *the_message() const {
    return GetPointer<const void *>(VT_THE_MESSAGE);
  }
  template<typename T> const T *the_message_as() const;
  const LoggingSystem::LogControlRequest *the_message_as_LogControlRequest() const {
    return the_message_type() == LoggingSystem::LogMessage_LogControlRequest ? static_cast<const LoggingSystem::LogControlRequest *>(the_message()) : nullptr;
  }
  const LoggingSystem::LogControlResponse *the_message_as_LogControlResponse() const {
    return the_message_type() == LoggingSystem::LogMessage_LogControlResponse ? static_cast<const LoggingSystem::LogControlResponse *>(the_message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_THE_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_THE_MESSAGE) &&
           VerifyLogMessage(verifier, the_message(), the_message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const LoggingSystem::LogControlRequest *LogMessageHolder::the_message_as<LoggingSystem::LogControlRequest>() const {
  return the_message_as_LogControlRequest();
}

template<> inline const LoggingSystem::LogControlResponse *LogMessageHolder::the_message_as<LoggingSystem::LogControlResponse>() const {
  return the_message_as_LogControlResponse();
}

struct LogMessageHolderBuilder {
  typedef LogMessageHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_the_message_type(LoggingSystem::LogMessage the_message_type) {
    fbb_.AddElement<uint8_t>(LogMessageHolder::VT_THE_MESSAGE_TYPE, static_cast<uint8_t>(the_message_type), 0);
  }
  void add_the_message(::flatbuffers::Offset<void> the_message) {
    fbb_.AddOffset(LogMessageHolder::VT_THE_MESSAGE, the_message);
  }
  explicit LogMessageHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogMessageHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogMessageHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogMessageHolder> CreateLogMessageHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoggingSystem::LogMessage the_message_type = LoggingSystem::LogMessage_NONE,
    ::flatbuffers::Offset<void> the_message = 0) {
  LogMessageHolderBuilder builder_(_fbb);
  builder_.add_the_message(the_message);
  builder_.add_the_message_type(the_message_type);
  return builder_.Finish();
}

inline bool VerifyLogMessage(::flatbuffers::Verifier &verifier, const void *obj, LogMessage type) {
  switch (type) {
    case LogMessage_NONE: {
      return true;
    }
    case LogMessage_LogControlRequest: {
      auto ptr = reinterpret_cast<const LoggingSystem::LogControlRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogMessage_LogControlResponse: {
      auto ptr = reinterpret_cast<const LoggingSystem::LogControlResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLogMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLogMessage(
        verifier,  values->Get(i), types->GetEnum<LogMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const LoggingSystem::LogMessageHolder *GetLogMessageHolder(const void *buf) {
  return ::flatbuffers::GetRoot<LoggingSystem::LogMessageHolder>(buf);
}

inline const LoggingSystem::LogMessageHolder *GetSizePrefixedLogMessageHolder(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LoggingSystem::LogMessageHolder>(buf);
}

inline bool VerifyLogMessageHolderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LoggingSystem::LogMessageHolder>(nullptr);
}

inline bool VerifySizePrefixedLogMessageHolderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LoggingSystem::LogMessageHolder>(nullptr);
}

inline void FinishLogMessageHolderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoggingSystem::LogMessageHolder> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLogMessageHolderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoggingSystem::LogMessageHolder> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace LoggingSystem

#endif  // FLATBUFFERS_GENERATED_LOGSCHEMA_LOGGINGSYSTEM_H_
